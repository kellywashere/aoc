Note: the number of presents each elf has is irrelevent, ony whether that nr is zero of non-zero.

Example:
1 2 3 4 5 6 7 8 9 10 11 12 <-- before we start, 1 has first turn
1   3   5   7   9    11    <-- after 1 round, 1 has next turn
1       5       9          <-- after 2 rounds, 1 has next turn
1               9          <-- after 3 rounds, 9 has next turn (!)
                9          <-- 9 wins

We describe the set of still remaining nrs as a:s:b
where a is the lowest nr in the set, b is the highest nr in the set
and s the spacing between the nrs
So: set is geven by: x is element of a + k*s, where a <= x <= b
and k an integer.

A round stops when we would otherwise wrap around the circle, either
for grabbing a gift, or passing the turn to the next one. Player t has
the next turn. t is either equal to the lowest or the highest value
player.

Before we start, we have x = 1:1:nmax (nmax the input of the puzzle), and t = 1.
a(1) = 1
s(1) = 1
b(1) = nmax
t(1) = 1

a(n): lowest valued player before round n
s(n): step size between nrs before round n
b(n): highest valued player before round n
t(n): player that starts round n (either a(n) or b(n))

After round 1 (so before round 2) we have:
1:2:b(2), where b(2) is the largest value of x = 1 + 2*k s.t. x <= b(1)
(or in other words: the largest odd nr in the original set).
If b(1) > b(2), apparently b(1) got eliminated in round 1 by player b(2),
who apparently just has had his turn. So if b(1) > b(2), t(2) = a(2).
If b(1) == b(2), t(2) = b(2) for similar reason.

Generalizing:
Before round n we have x = a(n):s(n):b(n)
Case 1: t(n) == a(n):
	a(n + 1) = a(n)
	s(n + 1) = 2 * s(n)
	b(n + 1) = a(n + 1) + k*s(n + 1) <= b(n)  (maximize k)
	So: k <= floor( (b(n) - a(n+1))/s(n+1) )
	b(n + 1) = a(n + 1) * floor( (b(n) - a(n+1))/s(n+1) ) * s(n + 1)
Case 2: t(n) = b(n)
	a(n + 1) = a(n) + s(n)   (next player after a(n))
	s(n + 1) = 2 * s(n)
	b(n + 1) = a(n + 1) + k*s(n + 1) <= b(n)  (maximize k)
	So: k <= floor( (b(n) - a(n+1))/s(n+1) )
	b(n + 1) = a(n + 1) * floor( (b(n) - a(n+1))/s(n+1) ) * s(n + 1)
Only difference is a(n + 1)

Concerning t(n + 1):
if b(n) > b(n + 1) then t(n + 1) = a(n + 1)
otherwise t(n + 1) = b(n + 1)

We keep running this recurrence until b(n) == a(n)
